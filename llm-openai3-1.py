import json
import os
import re
import subprocess
import sys
from openai import OpenAI
from cvss import CVSS3


if len(sys.argv) < 2:
    print("Usage: python3 llm-openai3-1.py <path_to_json_file>")
    sys.exit(1)

# Chemin du fichier json de la CVE à analyser
file_path = sys.argv[1]

# Configuration de la clé API d'OpenAI via variable d'environnement
api_key = os.getenv("OPENAI_API_KEY")
client = OpenAI(api_key=api_key)

def extract_cvss_vector(recommendation):
    # Regex pour capturer le vecteur CVSS en s'arrêtant au premier point, espace ou retour à la ligne.
    pattern = r"(CVSS:3\.1/)[A-Z][^.\s]*(?=[.\s])"
    match = re.search(pattern, recommendation)
    if match:
        return match.group(0)
    else:
        return None

def calcul_cvss(vector, has_exploit):
    """
    Calcule le score base CVSS pour un vecteur donné.

    Parameters:
    vector (str): Vecteur CVSS3.1 sous forme de chaîne de caractères.
    has_exploit (boolean): détermine la présence d'un exploit ou non

    Prints:
    Affiche le score CVSS ou un message d'erreur si le calcul échoue.
    """
    # s'il existe un exploit alors nous définissons la métrique Exploit Maturity (P) à Proof-of-Concept (P)
    if has_exploit:
        vector += "/E:P"
    else:
        vector += "/E:X"
    print("---------")
    print("Vecteur utilisé après analyse : ", vector)
    try:
        v = CVSS3(vector)
        print("Score final CVSS:", v.base_score)
    except Exception as e:
        print("Erreur lors du calcul du score CVSS:", e)

def check_exploit(cve_id):
    """
    Exécute un subprocess pour vérifier si une CVE possède un exploit connu dans la base de données Exploit-DB avec searchsploit.

    Parameters:
    cve_id (str): Identifiant CVE sous forme de chaîne de caractères

    Prints:
    Affiche le résultat de searchsploit ou un message d'erreur si l'exécution de la commande searchsploit échoue.
    """
    try:
        command = ['searchsploit', '--cve', cve_id]
        result = subprocess.run(command, capture_output=True, text=True)
        print("---------")
        print("Recherche d'exploit sur Exploit-DB:\n")

        if "Exploits: No Results" in result.stdout:
            print("Aucun exploit trouvé pour " + cve_id)
            return False
        else:
            print("Exploits trouvés pour " + cve_id + ":\n" + result.stdout)
            return True
    except subprocess.CalledProcessError as e:
        return "Une erreur s'est produite lors de la recherche d'exploits: " + str(e)

# Analyse de la CVE en utilisant chat.completions d'OpenAI
def analyser_cve(description, cvss_score):
    """
    Demande à l'API OpenAI d'analyser une description de CVE et de proposer un vecteur CVSS ajusté.

    Utilise le modèle GPT-4 pour générer une recommandation basée sur la description et le score CVSS
    actuel fournis. La recommandation inclut un vecteur CVSS ajusté et une justification
    de cet ajustement. La réponse est structurée pour une concision maximale.
    Le modèle est configuré avec une température de 0.00, ce qui le rend très déterministe
    et minimise la variabilité dans les réponses, maximisant ainsi la précision et la cohérence des recommandations
    générées.

    Parameters:
    description (str): La description de la vulnérabilité à analyser.
    cvss_score (float): Le score CVSS actuel de la vulnérabilité.

    Returns:
    str: La recommandation générée par l'API OpenAI. Retourne une chaîne de caractères avec la
         recommandation complète ou un message indiquant qu'aucune recommandation n'a été trouvée.

    Raises:
    openai.Error: Si une erreur se produit lors de la communication avec l'API OpenAI.
    """
    response = client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": """Rôle : Tu es un expert spécialisé dans l'analyse objective des vulnérabilités en informatique. 
Evalue la description suivante et le score CVSS qui est exprimé au format CVSS3.1. 
Corrige ces métriques si nécessaire en justifiant ta réponse.
Voici les valeurs possibles pour chaque métrique : 
Attack Vector (AV) : Network (N)/Adjacent (A)/Local (L)/Physical (P), 
Attack Complexity (AC) : Low (L)/High(H),
Privileges Required (PR) : None(N)/Low(L)/High(H), 
User Interaction (UI): None(N)/Required(R),
Scope (S): Unchanged(U)/Changed(C), 
Confidentiality (C):Low(L)/High(H)/None(N),
Integrity (I):Low(L)/High(H)/None(N), 
Availability (A):Low(L)/High(H)/None(N)
Voici un exemple de format de vecteur CVSS3 : CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:N
narrow: soit concis dans ta réponse."""},
            {"role": "user", "content": f"Description: {description}\nScore CVSS actuel: {cvss_score}"}
        ],
        max_tokens=5000,
        temperature=0.00
    )
    if response.choices and response.choices[0].message:
        return response.choices[0].message.content.strip()
    else:
        return "Aucune recommandation trouvée."
    
try:
    # Lecture du fichier JSON de la CVE
    with open(file_path, 'r') as file:
        cve_data = json.load(file)
        description = cve_data["descriptions"][0]["value"]
        cve_id = cve_data["id"]
        cvss_score = cve_data["metrics"]["cvssMetricV31"][0]["cvssData"]["baseScore"]
        
        # Analyse de la description et du score CVSS par OpenAI (modèle GPT-4)
        recommandation = analyser_cve(description, cvss_score)
        print(f"CVE: {cve_id}, Score CVSS Actuel: {cvss_score}\nRecommandation:\n{recommandation}")

        # Recherche d'exploit sur Exploit-DB
        has_exploit = check_exploit(cve_id)

        # Extraction du vecteur puis calcul de la CVSS
        vector = extract_cvss_vector(recommandation)
        if vector:
            calcul_cvss(vector, has_exploit)
        else:
            print("Aucun vecteur CVSS trouvé.")
                
except FileNotFoundError:
    print(f"Erreur: Le fichier '{file_path}' n'a pas été trouvé.")
except json.JSONDecodeError:
    print("Erreur: Le fichier n'est pas un JSON valide.")